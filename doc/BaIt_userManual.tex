\documentclass[11pt,a4paper,twocolumns]{article}
%% --------------------------------------------- PREAMBLE
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[italian,english]{babel}
\usepackage{lipsum}
%% Mathematics
\usepackage{amsmath,amssymb,amsthm}
%% Images & Graphics & Tables
\usepackage{graphicx}
\usepackage[usenames,dvipsnames,pdftex]{color}
\usepackage[pdftex]{hyperref}
\usepackage{booktabs}
\usepackage[labelfont=bf]{caption}

\usepackage{listings}
\lstset{basicstyle=\ttfamily\footnotesize,breaklines=true}

\usepackage{siunitx}
\usepackage{geometry}

%% Bibliography
\usepackage[autostyle,italian=guillemets,babel]{csquotes}
\usepackage[style=authoryear-comp,backend=biber,hyperref]{biblatex} % def stile per la biblio
\bibliography{bait_biblio}

%% --------------------------------------------- First Page TITLE
\title{\textbf{Ba\textit{It}: an Iterative Baer picker \\ -- \\ User Manual \\ \texttt{v2.1.6}}}
\author{Matteo Bagagli -- ETH, Zurich}
\date{\today}

%% --------------------------------------------- BEGIN DOCUMENT
\DeclareSIUnit\year{yr}

\begin{document}


%% --------------------------------------------- NewCommand
\newcommand{\bait}{\textbf{Ba}\textit{It} }
\newcommand{\mymail}{\texttt{matteo.bagagli@erdw.ethz.ch}}
%% ---------------------------------------------

\maketitle
\tableofcontents
\section{Introduction}
Identifying the arrival time of seismic energy at each offset receiver location has been fundamental to several seismic methods from purely scientific il prospecting since the beginnings of exploration seismology. 
To remove the burden of manual identification and picking of such transients, automatic picking softwares has been developed consistently throughout the last \SI{50}{\year} producing increasingly precise results.

In addition, it's safe to say that each seismic dataset can differ strongly from each others in terms of background noises, type of events (i.e. microseismic, teleseismic) and sensor's site effects.
Rarely, the usage of a single picking algorithm approach with fixed parameter configuration will provide satisfying results for the entire dataset. For this reason internal and intermediate evaluations steps are suggested to have a more stable tool for seismic phase picking.

The Python package here presented has the aim of overcome \emph{false} detection of seismic phase arrival, and provide an IRIS standard error uncertainty classification of the measurement. 
The idea of this simple but efficient tool emerged during the repicking procedure of the GAPSS dataset (M. Bagagli et al. in review) for a local earthquake traveltime tomography study. Because the waveforms were obtained by a temporary seismic network deployed over an exploited geothermal area, the final dataset was showing a lot of 
antropic and mechanical noises (ie spikes, small tremors) that were deceiveing regular pickers algorithms and therefore missing the true phase-arrival.

The \bait code use as main picking algorithm the Baer-Kradolfer (BK) picking algorithm \parencite[see][]{baer_automatic_1987} in a recursive manner throughout the waveform \emph{cuts} provided.
Every time a new detection is made, a set of fully-customazible test functions could be run, in order to validate the actual seismic nature of the pick. The strength of this package comes, in fact, from the possibility to fully define \emph{ad-hoc} datasets-dependent function based on user's needs.
An additional AIC picker can be optionally run on a closer time window around the validated picks to refine the onset measurament. This additional step will help also to overcome the systematic delay of the BK algoritmh.

Due to its ability in avoiding false detection and custom properties, this Python package is distributed with the hope that could be useful to the seismological community as well in different scenarios. The code can be downloaded from GitHub (provide link) and for any bug reports or open issues, please mail to \mymail.

%%% TIPS
%Picking algorithm have always been a foundamental part in the seismological routine workflows of observatories, and more often they have been such a painful step in the workflow for tuning and theri semi--automatic procedure as normally a cross-check by human eye is required.
%This steps, though, cannot be completely erased at the moment and neither this program show

%and have seen major improvements since the initial attempt of\parencite[see][]{allen_automatic_1982}.

\section{Installation}
A number of dependecies are requested and are listed in the \texttt{requirements.txt}. In order to avoid major issues and libraries conflicts it's strongly recommended to use a \emph{virtual environment}; for this task you could either use conda or pip--virtualenv as your preference.
To semplify this passage, a file is provided under the \texttt{config} folder~(\texttt{bait\_env.yml}), that you could use to generate the environment by typing:
\begin{lstlisting}[language=Python]
$ cd /where/the/package/is
$ conda env create -f ./config/bait_env.yml
\end{lstlisting}

Strictly speaking, the installation part is trivial: once the environment has been set-up, all you need to do is to open a terminal and type:
\begin{lstlisting}[language=Python]
$ cd /where/the/package/is
$ pip intall .
\end{lstlisting}

Once the package is successfully installed, you could verify the software integrity by tiping:
\begin{lstlisting}[language=Python]
$ cd /where/the/package/is
$ pytest
\end{lstlisting}

After all the test are passed, the software is ready to perform without any problems.
In case you would like to discuss specific issues, send few lines with the reported error to \mymail

\section{The code}
\subsection{Overview}
The \bait software has been developed in Python--3 and is distributed under the \emph{GPL-v3} license guidelines.
The code is written in object-oriented programming and can be easily embedded in already existing codes or routines. The package is composed by 3 different modules:
\begin{itemize}
\item[•] \texttt{bait.py}: this module contains all the main \bait class and can be considered the \emph{core} of this package.
\item[•] \texttt{bait\_customtests.py}: this module contains all the test-functions aimed at the pick validation and could be expanded with customizable test by the user (see Sect.\ref{sec:custom}).
\item[•] \texttt{bait\_plots.py}: this module contains the necessary function to plot the waveforms and relative \bait charachteristic functions and picks.
\item[•] \texttt{bait\_errors.py}: in this modules are contained various type of errors raised by the software. This module can be expanded with additional errors if the user require so (see Sect.\ref{sec:custom}).
\end{itemize}

The workflow of the picker is schematized in Fig.\ref{fig:workflow}. At the actual stage the \bait picking algorithm is able to detect properly the P-first arrival times and could detect sometimes the secondary as well, due to its recursive approach. As a common ground rule, is better to have a pre-processing stage prior the picking one.

The core picking-algorithm adopted by \bait, is the BK implemented in the ObsPy library. During the picking stage, the user could take advantage of the 2 different BK parameters: the first one (\emph{main}) is used on the first picking attempt only, while the second one (\emph{auxiliary}) is used for all the further steps.
In case of a missing \emph{auxiliary} set of picker-parameter, the \emph{main} one will be used also on the recursive step. The picking process is pursued throughout the waveform cut until the BK algorithm isn't able to identify further transients.

%%% TIPS
%This picking approach consist in apply \num{2} two different parameters setup of the same picker: if the first call doesn't return a pick, the waveform is discarded and no picks are found, while instead a pick is found an evaluation on the pick begins. If the evaluation is positive the pick is accepted as a first arrival and  the program switch to the next waveform. If the picks is negatively evaluated (rejected) a secondary setup on the trimmed trace is called (\textit{auxiliary picker}). From this point, if a pick is found it will be evaluated and eventually accepted, otherwise the waveform will be discarded and no first arrival will be assigned. If, the secondary picks are rejected, then the loop of trimming--picking--evaluating will continue until the maximum iteration number is reached.


\subsection{Picks evaluation stage}
Once a possible phase-arrival is detected, the pick evaluation stage will come in play to validate the effective seismic nature of the transient. This validation process is driven by the test functions and relative  parameters chosen. All the tests are performed over a carachteristic function derived overall the waveform stream given as input (Eq.\ref{eq:cf}). The \bait package comes with \num{2} already defined: \emph{SignalAmp} and \emph{SignalSustain}. For the following explanation, Fig.\ref{fig:example} will be used as reference.

\begin{equation}
	CF_{i}= \left|\frac{2\cdot(wave_{i}-min(wave))}{max(wave)-min(wave)}-1\right|
	\label{eq:cf}
\end{equation}

%
\subsubsection{SignalAmp}
This simple function will analyze and compare the maximum value of a so called \emph{signal window} defined in seconds after the analyzed pick against a threshold. If the maximum value of the window CF  exceed the threshold parameter, the test is passed (Eq.\ref{eq:test1}).

\begin{equation}
	max(W_{1}) \geqslant PAR_{1}
	\label{eq:test1}
\end{equation}

%
\subsubsection{SignalSustain}
This function will analyze the sustained energy of the detected transient. It analyze the mean \emph{signal to noise} ratio between each of the $n$ window slices (same temporal length) after the analyzed pick against a so called \emph{noise window} of a fixed length before the anlyzed pick (Eq.\ref{eq:test2}). The test is passed if the relation explained in the equation is valid for all the window slices.

\begin{equation}
	mean(W_{n}) \geqslant PAR_{2} \cdot mean(W_{0})
	\label{eq:test2}
\end{equation}

\section{Customization}
\label{sec:custom}
One of the interesting feature that this object oriented package provide is the ability to costumize, choose and develop test-functions for the validation process itself. The user can select from a list of already defined functions or create new ones to tackle particular issues related to specific \emph{false} detection of seismic transient.

In order to define a validation test functions, open the \texttt{bait\_customtests.py} and append a function definition at the end of the file, as:
\begin{lstlisting}[language=Python]
def my_validation_function(wt, par1,par2):
	""" Simple doc-string for usage """
	if par1 > par2:
		return True
	else:
		return False	
\end{lstlisting}
This is an useless and silly function, but it serves as reference. Two main points must be followed when creating new functions: the first parameter should point to an instance of an ObsPy.Trace class that contains the necessary waveforms, and the returning value should be booolean True or False in case the test is passed or not respectively.


%%% TIPS
%The evaluation stage is made of different test-functions that user can customize  The first one is to create a charachteristic function of the waveform as described in Eq.\ref{eq:cf} over which some user--customized tests will be performed to validate the pick. The The two tests performed to avoid mispicks in this dataset are represented by the two conditions described  in Eq.\ref{eq:test1} and Eq.\ref{eq:test2}.

%\section{Hands On}
%\subsection{Class definition \& parameters}


%\subsection{Example}

\printbibliography
\end{document}
